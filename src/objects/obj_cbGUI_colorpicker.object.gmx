<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>ico_colorpicker</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_cbGUI_parent</parentName>
  <maskName>spr_cbGUI_1x1</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

_type = 7;

_open = false;
_dragging = false;
_huedragging = false;
_changed = false;
_released = false;
_showInfo = false;
_copyToClipboard = false;

_hue = 0;
_sat = 255;
_val = 255;

_surface = -1;

_cx = 0; // color x
_cy = 0; // color y
_hy = 0; // hue y

value = -1;
value_hex = -1;

_bodyW = 32;
_bodyH = 16;
_border = 1;

image_xscale = _bodyW;
image_yscale = _bodyH;

_yoffset = 0; // prevents popup to go out of the view
_popupH = 110;

c_normal = $CCCCCC;
c_focus  = $EFEFEF;
c_disabled = $AAAAAA;
c_popup_bg = $121212;
c_popup_color_border = $CCCCCC;
c_info_light = c_focus;
c_info_dark = c_popup_bg;

font = cbDataGUIFont;

sprite_index = spr_cbGUI_1x1;

onChangeCallbackScript = undefined;
onReleaseCallbackScript = undefined;
_oCargs = undefined;
_oRargs = undefined;

_scr_colorpicker_setvalue(make_color_hsv(irandom_range(0, 255), irandom_range(0, 255), irandom_range(0, 255)));

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mouse interactions
if (disabled) exit; // skip if disabled
if (!visible) exit;

event_inherited();

_scr_colorpicker_step_mouse();

_scr_cbGUI_remote_handler();

if (_changed) {
    // call onChange callback
    value = make_colour_hsv(_hue, _sat, _val);
    value_hex = color_to_hex(value);
    _scr_colorpicker_invalidatesurface();
    _scr_cbGUI_onChange_cb_handler();
}

if (_onFocus &amp;&amp; _released) {
    // mouse button released
    // call onRelease callback
    if (_copyToClipboard) {
        clipboard_set_text(string(value));
        show_debug_message("Color is copied to clipboard");
    }
    _scr_cbGUI_onRelease_cb_handler();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var borderColor;

if (_onFocus) {
    borderColor = c_focus;
} else if (disabled) {
    borderColor = c_disabled;
} else {
    borderColor = c_normal;
}

d3d_transform_set_identity();
d3d_transform_set_rotation_z(rotation);
d3d_transform_add_translation(x, y, 0);
   
    // draw color box
    draw_set_alpha(alpha);
    draw_set_color(borderColor);
    draw_rectangle(0, 0, _bodyW, _bodyH, true);
    
    draw_set_color(value);
    draw_rectangle(_border, _border, _bodyW-_border, _bodyH-_border, false);
    
    if (_showInfo) {
        if (_val &lt; 138) draw_set_color(c_info_light);
        else draw_set_color(c_info_dark);
        
        draw_set_font(font);
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        draw_text(_bodyW / 2, _bodyH / 2, "\#" + string(value_hex));
    }
    
d3d_transform_set_identity();

// draw popup
if (!_open) exit;

if (!surface_exists(_surface)) {
    _surface = surface_create(128, 128);
    surface_set_target(_surface);
        
        draw_set_alpha(alpha);
        draw_set_color(c_popup_bg);
        
        // bg
        draw_rectangle(0, 0, 128, _popupH, false);
        
        // outline
        draw_set_color(c_popup_color_border);
        draw_rectangle(4, 4, 105, 105, true);
        draw_rectangle(107, 4, 123, 105, true);    
    
        // values
        for (var i = 0; i &lt; 100; i++) { // x / saturation
            for (var j = 0; j &lt; 100; j++) { // y / value (brightness)
                draw_point_colour(5+i, 5+j, make_colour_hsv(_hue, 2.55*i, 255-2.55*j));
            }
        }
        
        // hues
        for (var i = 0; i &lt; 15; i++) { // x / saturation
            for (var j = 0; j &lt; 100; j++) { // y / value (brightness)
                draw_point_colour(108 + i, 5+j, make_colour_hsv(255-2.55*j, 255, 255));
            }
        }
        
        // draw sprites
        draw_sprite(spr_cbGUI_colorpicker, 0, _cx + 5, _cy + 5);
        draw_sprite(spr_cbGUI_colorslider, 0, 123, _hy + 5);

    surface_reset_target();
}

if (surface_exists(_surface)) {
    draw_surface(_surface, x+_border/2, y+_bodyH+_border*2+_yoffset);
}


/*// debug
draw_set_font(cbGUIDebugFont);
    draw_set_colour(c_black);
    draw_set_halign(fa_left);
    draw_text(x, y + _bodyH + 122, "h:"+string(_hue)+ ", " + 
                                   "s:"+string(_sat)+ ", " +
                                   "v:"+string(_val)+ ", #" +
                                   "x:"+string(_cx)+ ", " +
                                   "y:"+string(_cy)+ ", " +
                                   "hy:"+string(_hy));

// bounding box
draw_set_alpha(.4);
draw_set_colour(c_red);
draw_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, false);
*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Do nothing

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///keyboard interactions
event_inherited();

if (disabled) exit; // skip if disabled
if (!visible) exit;
if (!_onFocus) exit; // skip if not on focus

var k = keyboard_lastkey;

// for arrow keys
 
switch (k) {

    case (vk_escape): 
        // cancel
        _onFocus = false;
        // changed
        break;
                 
    case (vk_left):
        // fast decrement
        if (keyboard_check(vk_shift)) changeAmount *= 5;
        
        // slow decrement
        _scr_slider_setcursorpos(_cursorX-1*changeAmount);
        break;

                    
    case (vk_right):
        // fast increment
        if (keyboard_check(vk_shift)) changeAmount *= 5;
        
        // slow increment
        _scr_slider_setcursorpos(_cursorX+1*changeAmount);
        break;    

                
    case (vk_up): case (vk_home):
        // go to min value
        _scr_slider_setvalue(minLimit);
        break;

                
    case (vk_down): case (vk_end): 
        // go to max value
        _scr_slider_setvalue(maxLimit);
        break;
}

keyboard_lastkey = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
